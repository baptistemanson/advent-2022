//use crate::debug::display;

pub fn pb1() {
    let mut field = parse(&INPUT);
    iterate(&mut field, 22);
    let r = count_empty(&field);
    dbg!(r);
}

pub fn pb2() {
    let mut field = parse(&INPUT);
    iterate(&mut field, 1000);
    count_empty(&field);
}

fn iterate(field: &mut Field, round: usize) {
    let mut output = field.clone();
    for i in 0..round {
        let mut has_moved = false;
        for (x, l) in field.iter().enumerate() {
            for (y, t) in l.iter().enumerate() {
                match t {
                    T::Elf(_, _) => {
                        // find destination
                        let r = find_destination(x, y, &field, i);
                        if r.is_none() {
                            output[x][y] = t.clone();
                            continue;
                        }
                        let (dest_x, dest_y) = r.unwrap();

                        // if elf => block this turn
                        match output[dest_x][dest_y] {
                            T::Blocked(a) if a == i => { /*noop*/ }
                            T::Blocked(_) => {
                                output[dest_x][dest_y] = T::Elf(x, y);
                                output[x][y] = T::Empty;
                            }
                            T::Empty => {
                                has_moved = true; // it will be T::Blocked(_) if it was already a candidate on the prev turn.
                                output[dest_x][dest_y] = T::Elf(x, y);
                                output[x][y] = T::Empty;
                            }
                            T::Elf(e_x, e_y) => {
                                // mark as blocked
                                output[dest_x][dest_y] = T::Blocked(i);
                                output[e_x][e_y] = T::Elf(e_x, e_y);
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
        std::mem::swap(field, &mut output);
        output = field.clone();
        if !has_moved {
            println!("ended at {}", i + 1);
            return;
        } else {
            // display(&field, 0);
        }
    }
}

fn find_destination(x: usize, y: usize, field: &Field, i: usize) -> Option<(usize, usize)> {
    let n = isnt_elf(x - 1, y, field, i);
    let nw = isnt_elf(x - 1, y - 1, field, i);
    let ne = isnt_elf(x - 1, y + 1, field, i);
    let w = isnt_elf(x, y - 1, field, i);
    let e = isnt_elf(x, y + 1, field, i);
    let s = isnt_elf(x + 1, y, field, i);
    let sw = isnt_elf(x + 1, y - 1, field, i);
    let se = isnt_elf(x + 1, y + 1, field, i);
    if n && nw && ne && w && e && s && sw && se {
        return None;
    }
    for a in 0..4 {
        let rule_rot = (a + i) % 4;
        match rule_rot {
            0 => {
                // If there is no Elf in the N, NE, or NW adjacent positions, the Elf proposes moving north one step.
                if n && ne && nw {
                    return Some((x - 1, y));
                }
            }
            1 => {
                // If there is no Elf in the S, SE, or SW adjacent positions, the Elf proposes moving south one step.
                if s && se && sw {
                    return Some((x + 1, y));
                }
            }
            2 => {
                // If there is no Elf in the W, NW, or SW adjacent positions, the Elf proposes moving west one step.
                if w && nw && sw {
                    return Some((x, y - 1));
                }
            }
            _ => {
                // 3 case
                // If there is no Elf in the E, NE, or SE adjacent positions, the Elf proposes moving east one step.
                if e && ne && se {
                    return Some((x, y + 1));
                }
            }
        }
    }
    None
}

fn isnt_elf(x: usize, y: usize, field: &Field, i: usize) -> bool {
    if field[x][y] == T::Empty {
        true
    } else if let T::Blocked(a) = field[x][y] {
        return a != i;
    } else {
        false
    }
}

fn count_empty(field: &Field) -> i32 {
    let min_x = field.iter().position(|l| l.iter().any(is_elf)).unwrap();
    let max_x = field.len()
        - field
            .iter()
            .rev()
            .position(|l| l.iter().any(is_elf))
            .unwrap();
    let min_y = field
        .iter()
        .map(|l| l.iter().position(is_elf).unwrap_or(usize::MAX))
        .min()
        .unwrap();
    let max_y = field
        .iter()
        .map(|l| l.len() - l.iter().rev().position(is_elf).unwrap_or(l.len()))
        .max()
        .unwrap();
    let mut count = 0;
    for x in min_x..max_x {
        for y in min_y..max_y {
            match field[x][y] {
                T::Empty => count += 1,
                T::Blocked(_) => count += 1,
                _ => continue,
            }
        }
    }
    count
}

fn is_elf(t: &T) -> bool {
    match t {
        T::Elf(_, _) => true,
        _ => false,
    }
}

fn parse(input: &str) -> Field {
    let dim_x = input.lines().count();
    let dim_y = input.lines().next().unwrap().len();
    let margin_fact = 1;
    let mut output =
        vec![vec![T::Empty; dim_y * (2 * margin_fact + 1)]; dim_x * (2 * margin_fact + 1)];
    input.lines().enumerate().for_each(|(x, l)| {
        l.chars().enumerate().for_each(|(y, c)| {
            output[x + margin_fact * dim_x][y + margin_fact * dim_y] = match c {
                '.' => T::Empty,
                _ => T::Elf(0, 0),
            }
        })
    });
    output
}

type Field = Vec<Vec<T>>;
type Clock = usize;

#[derive(Debug, Clone, PartialEq, Eq)]
enum T {
    Empty,
    Elf(usize, usize),
    Blocked(Clock),
}

impl ToString for T {
    fn to_string(&self) -> String {
        match self {
            T::Elf(_, _) => String::from("#"),
            T::Blocked(_) => String::from("b"),
            _ => String::from("."),
        }
    }
}
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_1() {}
}

#[allow(dead_code)]
const INPUT_CUSTOM: &str = "";

#[allow(dead_code)]
const INPUT_TEST: &str = "\
..............
..............
.......#......
.....###.#....
...#...#.#....
....#...##....
...#.###......
...##.#.##....
....#..#......
..............
..............
..............";

#[allow(dead_code)]
const INPUT: &str = "\
.###.#.#.#..###.##.#.....#.####.####..##.#.##.#....##.###.#..####.##.#.
.###.#...######....##.#..###..#.#.##.#.######..##.#.....#...#.#.##.##..
.##....#..#...#..##.....##......#.#..#......#..#..###..#..##..#.#.##.#.
#####.###.##.#.##.#.#...##.##.#.#..####...#.#..####.#.######.###.######
#...#.#.#####....#.#.###..#####..####.#.#....###.#.####..##..###.####..
#.#.#.#####.....#....##....####.#..#...##.##..##..##..#..#...####.#..##
....#.#..####.#...#........##...##...#.##.##########...###..#####.#...#
.####.#...##.#..##....###.##..#.###.#.##..######.##.#.#.##....##..#....
..#...#...#..#####......#.....#.##..#.####.##...#####..#..###.#..##....
#..#.#.#....####...#..##..#...#..#.#####.#.##..###.#.#.#...#######.#...
.#.#.####....###...#..#.#...#.#.####..#..#........#..###....########.#.
#.##.#.##.#...#.##.###....##...####.###...#.##.##..##....#...####.#..#.
.#.#.#.#..###..#.####..######.##..#.#######...####.#.#.#.##...#.....###
#..###...##......#..#....#..#..##......#####...#.##.....#.###..#...#..#
.####...#.#....###.#.....#.##.#.....##...##.....#..#####..###.##.#.#.##
..#...#.#.#...##########..###.###....#..###....##..#.########.##.#.#.##
####..#..#.####...####..##.##.##....#..###.###.......##.......#.##...##
...#####..#.####.#.#.#.###..#..#..#.##.##..#.###.###.#...#.#.##.....#..
##..###.##.###.##.####.#.#.....##.##.#..###..####..########.###..###.##
#.#.#..#....###.#...#.#...#..###.###..#.##.##.####.##.##.##..#..###..##
#..###.....##.#####.###..##.###.#.....##.#....###..######..##.#.###...#
#.##..##.#.#.#.##.#..##..#..##..#....#..###.......###.####..##...#.#.#.
##...#..##..#.#..##.##...#.#.#..####.#..##...#.#...######....##.#...#..
#.###...#####..####..##..##.###..##.#.####..##.#.###.#.#..#......#.....
.#...#.#.###........#.#.#...#..####...#.#####.#####...#....###.##.###..
....###....####..##..###.##..##.##.#.###.##.#.#.....#.....###.##...##..
#....######.....#.#...#.#..###.....#....#..##.##.###..##....#.###...#..
#.#.#.#.#...#.#.#...#.#.....####.###.#####.#.##..###..#.#####.#......#.
.##.####...######.#.###.##.###..#.##..#.#.#....##.#.#####.#...####....#
.#.#.##..##..###.#.#....####....#......#..##..###..########...#.##.##.#
#.###.##...#....#..###..#......##..#....#.####..#.##..#.##.#.##.#...###
#..#....##.###..###..##..#...#......#..####.#.#.#######.#...#####..#..#
..#.###.#..###.###......#.####..###..#.#..#.#.....##...#..#.#.##.###...
...##.........#..###.##..#######.######....######.#####.#.#.#.#..######
###.##..###.#.####...###..#..#...#...##.#.#......#..#.###..#.#...#....#
...###....##....#.##.#...###....##.#...#..#...#.#.##..#..#..####....#.#
.#.#..#########....#.##.##..#.##..##.###..#.###..##.#..#.####.#.##.##..
##..####..###.#.....#.#.#.##...#.##....##.#.#.....##.....#..##.#.##.##.
#..#.######.#.###...#..#.#.###.##.##.#.###.....#.......####..#...###..#
.##..##.###.#.###.#######.#.#.#.##.#....#...#####....###.######..#..##.
#.####....#..#...###.....###..##...###....##.#..#..##...##..#.####..#..
..###.##.###.#.#....##.####.#.#...#.#####.####..#.#.#.###.##.###...####
##.##..#..##.....#####..####.##.#.#.##..##.#.#..##..#.##.#.#....####...
###.#.#....#...#...#.#...#.#..#.#.###.###.##..#..#..###.##..#.#...##...
...#.....#.##...##....##...##.#.#..#.##.#.#..##.####.#.##..#.......#...
#....####.#.....###.##.#.###.#####.##....#.##..#####.....#.##.##..###.#
.#..#..##.#..##.#.######.##...##...#.##..##..#.#.#..##.#....##...######
....##.##.#...#.###....##..#..#..#..#...#...####.##.########.###..##..#
###...####......#.#..#..#.##.####.#.##.#.##.#..##.#..###..####..#.#.###
..#####...#.#.....#....####.##..##.##..###...##.###..##.####.####..###.
..#.##.##...##..##.#..##.#.###...#.#..##.#.##.###.#.#.#.#.#..#..##.#..#
.#.....#..####..#...#.#..####.#####.#..###.##.###.###.#.......####.##..
.#.#####.#....#..##..#.###.####.#.....#..#.####..#.#.#....#.##.##..###.
.....#...#.#..#.#.#.#.##..####.##.##.###.#......#..#.##...####.#.#.#.#.
##...#..#..##..##..#...#.##.###....#..#..##..#.##.#.###.###.#....#.##..
#.##.##...#.....##...###.#####..###..#.#.#..#.#.....#####.###.#..##...#
.###..#.#.#...###.##...##...#..#.#.#...#.###....###......#.#.###..###.#
###..#...###...#.#.##.#..##.#.....#..##.#..#########..##.#.###.#.#.#...
.##.#.#.#.#...#...##.##..#.##..#########..#.##.###.##.####.#.##.####.##
##.#####...##.....##.....##....###...#....#...#.##.#..##.#...#.#.#...#.
##....#.#....##.##..###....####.#...######.#..##......#.####...#.#.##.#
#####.#...#.....###....#.##....#..#.##.#####.########.###.#..#.##.#..##
##..#.#..##.#.##...#...##.#####.###.####.#...##...###...##..#...###.###
#.##..#....######..#.###.....#.#.####.##..##.##.#####......#.#.###..###
.#####..####.#.##...###.....#######..######.#.##....#..##.##.##.##.#.##
...##.....#.###.####.#.###.#......##.#....#..###.....#.###.......####..
.#.########..#.#...###.#.##....#.##.####.#.##....#.###.#.####.#.#...##.
.###.#.#.#.#..#.##..#####..#######...#...#..######.....###...##.#.##.#.
.#.....##..#.#..##.#.#..#.#..##.#..#...##..######.#.########...###.#...
..###.##..#.##..#........#.#....###..#.....##.##.##..#.##..###.#...#.##
..#.####.######.#......#...###.#...##.#...###.###.#..###.#..##.#..####.";
